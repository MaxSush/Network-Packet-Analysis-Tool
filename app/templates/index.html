<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Charts in Cards</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .dropdown-menu {
            max-height: 300px;
            overflow-y: auto;
            padding-left: 20px;
            padding-right: 20px;
            /* Add padding inside the dropdown menu */
        }

        .port-input {
            display: none;
            /* Hidden by default */
            margin-top: 10px;
        }

        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
            /* Remove number increment/decrement buttons */
        }

        input[type="number"] {
            -moz-appearance: textfield;
            /* For Firefox */
        }

        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        .card {
            margin: 15px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .card-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .card:hover {
            transform: scale(1.03);
        }

        #chartContainer {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }

        .card canvas {
            height: 200px !important;
        }

        a {
            text-decoration: none;
            color: inherit;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="text-center mb-4">
            <div class="alert alert-primary" role="alert" style="background-color: #7cbad8;">
                <h1>Welcome to Far_Annoyed</h1>
            </div>
        </div>

        <div class="container mt-5">
            <h3>Select Filters:</h3>
            <div class="dropdown">
                <button class="btn btn-primary dropdown-toggle" type="button" id="filterDropdownButton"
                    data-bs-toggle="dropdown" aria-expanded="false">
                    Select Filters
                </button>
                <ul class="dropdown-menu" aria-labelledby="filterDropdownButton">
                    <li>
                        <div class="form-check">
                            <input class="form-check-input filter-checkbox" type="checkbox" value="TCP" id="filter-tcp"
                                aria-label="Filter TCP Only">
                            <label class=" form-check-label" for="filter-tcp">TCP Only</label>
                        </div>
                    </li>
                    <li>
                        <div class="form-check">
                            <input class="form-check-input filter-checkbox" type="checkbox" value="UDP" id="filter-udp">
                            <label class="form-check-label" for="filter-udp">UDP Only</label>
                        </div>
                    </li>
                    <li>
                        <div class="form-check">
                            <input class="form-check-input filter-checkbox" type="checkbox" value="ARP" id="filter-arp">
                            <label class="form-check-label" for="filter-arp">ARP</label>
                        </div>
                    </li>
                    <li>
                        <div class="form-check">
                            <input class="form-check-input filter-checkbox" type="checkbox" value="Specific Port"
                                id="filter-specific-port">
                            <label class="form-check-label" for="filter-specific-port">Specific Port</label>
                        </div>
                    </li>
                    <li class="port-input" id="portInputContainer">
                        <label for="portInput" class="form-label">Enter Port:</label>
                        <input type="number" class="form-control" id="portInput" placeholder="e.g., 80" min="1"
                            max="65535">
                        <span id="portError" class="text-danger"></span>
                    </li>
                </ul>
            </div>

            <button class="btn btn-success mt-3" onclick="applyFilters()">Apply Filters</button>
            <div class="mt-3">
                <strong>Selected Filters:</strong>
                <span id="selectedFilters">None</span>
            </div>
        </div>


        <div id="chartContainer" class="row"></div>
    </div>

    <script>
        // for filters
        const MAX_PORT = 65535;

        // Show/hide the specific port input field
        document.getElementById('filter-specific-port').addEventListener('change', function () {
            const portInputContainer = document.getElementById('portInputContainer');
            portInputContainer.style.display = this.checked ? 'block' : 'none';
        });

        function applyFilters() {
            const selectedFilters = [];
            const checkboxes = document.querySelectorAll('.filter-checkbox');
            const specificPortInput = document.getElementById('portInput');
            const portValue = specificPortInput.value.trim();

            checkboxes.forEach((checkbox) => {
                if (checkbox.checked) {
                    if (checkbox.value === 'Specific Port') {
                        const portNumber = parseInt(portValue, 10);
                        if (portNumber >= 1 && portNumber <= MAX_PORT) {
                            selectedFilters.push(`Port ${portNumber}`);
                            portError.textContent = '';
                        } else {
                            portError.textContent = `Please enter a valid port number (1-${MAX_PORT}).`;
                        }
                    } else {
                        selectedFilters.push(checkbox.value);
                    }
                }
            });

            // Display selected filters
            document.getElementById('selectedFilters').textContent =
                selectedFilters.length > 0 ? selectedFilters.join(', ') : 'None';

            return selectedFilters;
        }
        // For charts 
        const charts = {}; // Holds chart instances
        const maxDataPoints = 50; // Max number of points per chart
        const chartContainer = document.getElementById('chartContainer');

        // Function to create a card for each chart
        function createCard(interfaceName) {
            const col = document.createElement('div');
            col.className = "col-md-4";

            const card = document.createElement('div');
            card.className = "card";
            card.style.cursor = "pointer"; // Make it look clickable

            const cardBody = document.createElement('div');
            cardBody.className = "card-body";

            const title = document.createElement('h5');
            title.className = "card-title text-center";
            title.textContent = interfaceName;

            const canvas = document.createElement('canvas');
            canvas.id = `chart-${interfaceName}`;

            cardBody.appendChild(title);
            cardBody.appendChild(canvas);
            card.appendChild(cardBody);
            col.appendChild(card);
            chartContainer.appendChild(col);

            const ctx = canvas.getContext('2d');
            charts[interfaceName] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: new Array(50).fill(1),
                    datasets: [{
                        label: interfaceName,
                        data: [0],
                        borderColor: `rgba(0, 0, 0, 1)`,
                        borderWidth: 2,
                        tension: 0,
                        fill: false,
                    }],
                },
                options: {
                    plugins: {
                        legend: { display: false },
                    },
                    scales: {
                        x: { display: false },
                        y: { display: false },
                    },
                    elements: { point: { radius: 0 } },
                    maintainAspectRatio: false,
                    animation: false,
                },
            });

            // Add click event to redirect with filters
            card.addEventListener('click', () => {
                const selectedFilters = applyFilters();
                const url = new URL(`/interface/${interfaceName}`, window.location.origin);

                if (selectedFilters.length > 0) {
                    url.searchParams.append('filters', encodeURIComponent(selectedFilters.join(',')));

                }

                // Redirect to the interface page
                window.location.href = url.toString();
            });
        }

        // Function to update chart data
        function updateChart(interfaceName, value) {
            const chart = charts[interfaceName];
            chart.data.datasets[0].data.push(value); // Add new value

            // Trim old data to avoid performance issues
            if (chart.data.datasets[0].data.length > maxDataPoints) {
                chart.data.datasets[0].data.shift();
            }

            chart.update(); // Update the chart with animation
        }

        // Function to fetch and update data
        async function fetchData() {
            try {
                const response = await fetch('/data');
                const result = await response.json();
                const values = result.value; // List of packet counts
                const interfaces = result.interfaces; // List of interface names
                if (!Array.isArray(values) || !Array.isArray(interfaces)) {
                    console.error('Invalid response format');
                    return;
                }
                interfaces.forEach((interfaceName, index) => {
                    if (!charts[interfaceName]) {
                        createCard(interfaceName); // Create card and chart if not exists
                    }
                    updateChart(interfaceName, values[index]); // Update chart with new data
                });
            } catch (error) {
                console.error('Error fetching data:', error);
            }
        }

        // Fetch data every second
        setInterval(fetchData, 1000);

    </script>
</body>

</html>